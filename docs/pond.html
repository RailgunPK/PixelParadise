<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fish Pond (Circle)</title>
  <style>
    body { margin: 0; background: transparent; }
    .pond-wrap { width: 500px; height: 500px; position: relative; }
    canvas {
      width: 500px; height: 500px; display: block;
      border-radius: 50%;
      background: transparent;
      user-select: none; -webkit-user-select: none;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div class="pond-wrap">
    <canvas id="pond" width="500" height="500"></canvas>
  </div>

  <script>
  (() => {
    // -------------------------
    // Config
    // -------------------------
    const SIZE = 500;
    const R = SIZE / 2;

    const FOOD_LIFE_MS = 7000;
    const FOOD_SPAWN_COUNT = 18;
    const FOOD_DRIFT = 0.06;

    // Half as many fish
    const FISH_COUNT = 5;

    // Food behavior
    const SENSE_RADIUS = 160;
    const EAT_RADIUS = 10;

    // Speeds (half of your "slow" set again)
    const MIN_SPEED = 0.10;
    const MAX_SPEED = 0.27;

    // Steering / forces
    const DAMPING = 0.985;          // velocity damping each frame
    const STEER = 0.055;            // how strongly fish respond to forces
    const WANDER_FORCE = 0.055;     // random swim force magnitude
    const WANDER_SMOOTH = 0.020;    // how slowly wander direction changes (smaller = smoother)
    const CENTER_FORCE = 0.075;     // pulls toward center (prevents edge orbits)

    // Edge control (kills circling)
    const EDGE_ZONE = 120;          // distance-from-edge where we start applying extra control
    const RADIAL_DAMP = 0.70;       // damp tangential motion near edge (reduces orbit)
    const INWARD_KICK = 0.16;       // inward nudge when too close to edge

    // Speed variation
    const SPEED_WOBBLE = 0.20;
    const SPEED_WOBBLE_RATE = 0.0011;
    const BURST_CHANCE = 0.0010;
    const BURST_MULT_MIN = 1.05;
    const BURST_MULT_MAX = 1.18;
    const BURST_MS_MIN = 250;
    const BURST_MS_MAX = 650;

    const CHASE_FORCE = 0.10;       // pull strength toward food
    const CHASE_SPEED_BOOST = 1.06; // mild

    // -------------------------
    // Canvas
    // -------------------------
    const canvas = document.getElementById("pond");
    const ctx = canvas.getContext("2d", { alpha: true });
    ctx.imageSmoothingEnabled = false;

    // -------------------------
    // Helpers
    // -------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => a + Math.random() * (b - a);

    function insideCircle(x, y, pad = 0) {
      const dx = x - R, dy = y - R;
      return (dx*dx + dy*dy) <= (R - pad)*(R - pad);
    }

    // Boundary clamp that *stops* the "bounce loop"
    function keepInsideCircle(entity, pad = 16) {
      const dx = entity.x - R;
      const dy = entity.y - R;
      const d = Math.hypot(dx, dy) || 1;
      const maxD = R - pad;

      if (d > maxD) {
        const nx = dx / d;
        const ny = dy / d;

        entity.x = R + nx * maxD;
        entity.y = R + ny * maxD;

        // Remove outward velocity component strongly
        const vDotN = entity.vx * nx + entity.vy * ny;
        if (vDotN > 0) {
          entity.vx -= nx * vDotN * 2.2;
          entity.vy -= ny * vDotN * 2.2;
        }

        // Dampen so we don't get rapid edge jitter
        entity.vx *= 0.80;
        entity.vy *= 0.80;

        // Small inward push to get them away from the rim
        entity.vx -= nx * 0.18;
        entity.vy -= ny * 0.18;
      }
    }

    // -------------------------
    // Pixel fish sprite generator
    // -------------------------
    function makeFishSprite(palette) {
      const w = 12, h = 8;
      const map = [
        "000011110000",
        "000111111000",
        "001111111100",
        "011111111110",
        "011111111110",
        "001111111100",
        "000111111000",
        "000011110000",
      ];

      const body = [];
      for (let y=0; y<h; y++) body[y] = map[y].split("").map(c => (c==="1" ? 1 : 0));

      // Tail + fin + eye
      for (let y=2; y<=5; y++) body[y][0] = 2;
      body[3][1] = 2; body[4][1] = 2;
      body[3][2] = 0; body[4][2] = 0;

      body[1][6] = 2;
      body[2][7] = 2;
      body[3][9] = 3;

      const scale = 2;
      const off = document.createElement("canvas");
      off.width = w * scale;
      off.height = h * scale;
      const o = off.getContext("2d");
      o.imageSmoothingEnabled = false;

      const colors = { 1: palette.body, 2: palette.accent, 3: palette.eye };
      for (let y=0; y<h; y++) for (let x=0; x<w; x++) {
        const v = body[y][x];
        if (!v) continue;
        o.fillStyle = colors[v];
        o.fillRect(x*scale, y*scale, scale, scale);
      }
      return off;
    }

    const palettes = [
      { body:"#ff8a3d", accent:"#fff2d2", eye:"#1b1b1b" },
      { body:"#ff5b6e", accent:"#ffd6dc", eye:"#1b1b1b" },
      { body:"#7dd6ff", accent:"#d8f5ff", eye:"#1b1b1b" },
      { body:"#ffd84a", accent:"#fff2b0", eye:"#1b1b1b" },
      { body:"#a6ff7a", accent:"#e3ffd2", eye:"#1b1b1b" }
    ];
    const fishSprites = palettes.map(makeFishSprite);

    // -------------------------
    // Entities
    // -------------------------
    const fish = Array.from({ length: FISH_COUNT }, (_, i) => {
      // Spawn near center to avoid initial rim motion
      let x, y;
      do { x = rand(170, SIZE-170); y = rand(170, SIZE-170); } while (!insideCircle(x,y,170));

      const a = rand(0, Math.PI*2);
      const baseSpeed = rand(MIN_SPEED, MAX_SPEED);

      return {
        x, y,
        vx: Math.cos(a) * baseSpeed,
        vy: Math.sin(a) * baseSpeed,

        baseSpeed,
        speed: baseSpeed,
        wobblePhase: rand(0, 99999),
        burstUntil: 0,
        burstMult: 1,

        // wander vector (we smooth toward a random target vector)
        wx: Math.cos(rand(0, Math.PI*2)),
        wy: Math.sin(rand(0, Math.PI*2)),
        wtx: Math.cos(rand(0, Math.PI*2)),
        wty: Math.sin(rand(0, Math.PI*2)),
        wTimer: rand(400, 1400),

        sprite: fishSprites[i % fishSprites.length],
      };
    });

    const food = [];

    function addFood(cx, cy) {
      for (let i=0; i<FOOD_SPAWN_COUNT; i++) {
        const ang = rand(0, Math.PI*2);
        const rad = Math.sqrt(Math.random()) * 22;
        const x = cx + Math.cos(ang) * rad;
        const y = cy + Math.sin(ang) * rad;
        if (!insideCircle(x,y,10)) continue;

        food.push({
          x, y,
          vx: rand(-FOOD_DRIFT, FOOD_DRIFT),
          vy: rand(-FOOD_DRIFT, FOOD_DRIFT),
          born: performance.now(),
          size: rand(1.2, 2.2)
        });
      }
    }

    // -------------------------
    // Input
    // -------------------------
    function getCanvasPos(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (canvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (canvas.height / rect.height);
      return { x, y };
    }

    canvas.addEventListener("pointerdown", (e) => {
      const { x, y } = getCanvasPos(e);
      if (!insideCircle(x, y, 0)) return;
      addFood(x, y);
    });

    // -------------------------
    // Update
    // -------------------------
    function updateFishSpeed(b, now, dt) {
      b.wobblePhase += dt * SPEED_WOBBLE_RATE;
      const wobble = (Math.sin(b.wobblePhase) + 0.35 * Math.sin(b.wobblePhase * 0.61)) * 0.5;
      let targetSpeed = b.baseSpeed * (1 + wobble * SPEED_WOBBLE);

      if (now > b.burstUntil && Math.random() < BURST_CHANCE) {
        b.burstMult = rand(BURST_MULT_MIN, BURST_MULT_MAX);
        b.burstUntil = now + rand(BURST_MS_MIN, BURST_MS_MAX);
      }
      if (now <= b.burstUntil) targetSpeed *= b.burstMult;

      targetSpeed = clamp(targetSpeed, MIN_SPEED * 0.9, MAX_SPEED * 1.25);
      b.speed += (targetSpeed - b.speed) * 0.035;
    }

    function updateWander(b, dt) {
      b.wTimer -= dt;
      if (b.wTimer <= 0) {
        b.wTimer = rand(500, 1600);
        const ang = rand(0, Math.PI*2);
        b.wtx = Math.cos(ang);
        b.wty = Math.sin(ang);
      }

      // Smooth wander direction toward target
      b.wx += (b.wtx - b.wx) * WANDER_SMOOTH;
      b.wy += (b.wty - b.wy) * WANDER_SMOOTH;
      const d = Math.hypot(b.wx, b.wy) || 1;
      b.wx /= d; b.wy /= d;
    }

    function update(dt) {
      const now = performance.now();

      // Food aging + drift
      for (let i = food.length - 1; i >= 0; i--) {
        const f = food[i];
        const age = now - f.born;
        if (age > FOOD_LIFE_MS) { food.splice(i,1); continue; }

        f.x += f.vx * dt;
        f.y += f.vy * dt;

        if (!insideCircle(f.x, f.y, 4)) {
          const dx = f.x - R, dy = f.y - R;
          const d = Math.hypot(dx, dy) || 1;
          const maxD = R - 4;
          f.x = R + (dx/d) * maxD;
          f.y = R + (dy/d) * maxD;
          f.vx *= -0.5; f.vy *= -0.5;
        }
      }

      for (const b of fish) {
        updateFishSpeed(b, now, dt);
        updateWander(b, dt);

        // Find nearest food
        let target = null;
        let bestD2 = SENSE_RADIUS * SENSE_RADIUS;
        for (const f of food) {
          const d2 = (b.x - f.x)*(b.x - f.x) + (b.y - f.y)*(b.y - f.y);
          if (d2 < bestD2) { bestD2 = d2; target = f; }
        }

        // Compute forces
        let fx = 0, fy = 0;

        // Wander force
        fx += b.wx * WANDER_FORCE;
        fy += b.wy * WANDER_FORCE;

        // Center force (always on)
        const cx = (R - b.x);
        const cy = (R - b.y);
        const cd = Math.hypot(cx, cy) || 1;
        fx += (cx / cd) * CENTER_FORCE;
        fy += (cy / cd) * CENTER_FORCE;

        // Edge control: reduce orbit by damping tangential component near edge + inward kick
        const fromCenterX = b.x - R;
        const fromCenterY = b.y - R;
        const distFromCenter = Math.hypot(fromCenterX, fromCenterY) || 1;
        const edgeDist = (R - 16) - distFromCenter;

        if (edgeDist < EDGE_ZONE) {
          const nx = fromCenterX / distFromCenter; // outward normal
          const ny = fromCenterY / distFromCenter;

          const t = clamp(1 - (edgeDist / EDGE_ZONE), 0, 1); // 0..1

          // Inward nudge grows near edge
          fx -= nx * INWARD_KICK * t;
          fy -= ny * INWARD_KICK * t;

          // Tangential damping: remove sideways "orbit" velocity near edge
          // tangent = v - (vÂ·n)n
          const vDotN = b.vx * nx + b.vy * ny;
          const tx = b.vx - vDotN * nx;
          const ty = b.vy - vDotN * ny;

          b.vx -= tx * (RADIAL_DAMP * t) * 0.06;
          b.vy -= ty * (RADIAL_DAMP * t) * 0.06;
        }

        // Chase force
        let speedBoost = 1.0;
        if (target) {
          const dx = target.x - b.x;
          const dy = target.y - b.y;
          const d = Math.hypot(dx, dy) || 1;

          fx += (dx / d) * CHASE_FORCE;
          fy += (dy / d) * CHASE_FORCE;
          speedBoost = CHASE_SPEED_BOOST;

          if (d <= EAT_RADIUS) {
            const idx = food.indexOf(target);
            if (idx >= 0) food.splice(idx, 1);
          }
        }

        // Apply forces to velocity (scaled by dt)
        const step = (dt / 16.6667); // normalize to ~60fps
        b.vx += fx * STEER * step;
        b.vy += fy * STEER * step;

        // Global damping (smooth, prevents jitter/spin)
        b.vx *= DAMPING;
        b.vy *= DAMPING;

        // Clamp speed toward desired
        const sp = Math.hypot(b.vx, b.vy) || 1;
        const desired = b.speed * speedBoost;
        const max = desired * 1.15;

        if (sp > max) {
          b.vx = (b.vx / sp) * max;
          b.vy = (b.vy / sp) * max;
        } else if (sp < desired * 0.55) {
          // gentle "minimum swim" so they don't stall
          b.vx += (b.vx / sp) * 0.003;
          b.vy += (b.vy / sp) * 0.003;
        }

        // Move
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        keepInsideCircle(b, 16);
      }
    }

    // -------------------------
    // Render
    // -------------------------
    function render() {
      ctx.clearRect(0,0,SIZE,SIZE);

      ctx.save();
      ctx.beginPath();
      ctx.arc(R, R, R, 0, Math.PI*2);
      ctx.clip();

      // Food
      const now = performance.now();
      for (const f of food) {
        const age = now - f.born;
        const t = 1 - (age / FOOD_LIFE_MS);
        ctx.globalAlpha = clamp(t, 0, 1);
        ctx.fillStyle = "#7a4b12";
        ctx.fillRect(
          Math.round(f.x),
          Math.round(f.y),
          Math.max(1, Math.round(f.size)),
          Math.max(1, Math.round(f.size))
        );
      }
      ctx.globalAlpha = 1;

      // Fish
      for (const b of fish) {
        const spr = b.sprite;
        const w = spr.width, h = spr.height;

        // Face direction of movement; avoid noisy rotation when nearly stopped
        const sp = Math.hypot(b.vx, b.vy);
        const ang = (sp > 0.02) ? Math.atan2(b.vy, b.vx) : 0;

        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(ang);

        const bob = Math.sin((performance.now() * 0.006) + b.wobblePhase * 0.01) * 0.7;
        ctx.translate(0, bob);

        ctx.drawImage(spr, -w/2, -h/2);
        ctx.restore();
      }

      ctx.restore();
    }

    // -------------------------
    // Loop
    // -------------------------
    let last = performance.now();
    function loop() {
      const now = performance.now();
      const dt = Math.min(33, now - last);
      last = now;

      update(dt);
      render();
      requestAnimationFrame(loop);
    }
    loop();

    window.POND = { fish, food, addFood };
  })();
  </script>
</body>
</html>